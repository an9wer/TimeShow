<!DOCTYPE html>
<html>
<head>
    <title>an9wer's blog</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link rel="stylesheet" href="../statics/css/style.css" type="text/css" />
    <link rel="icon" href="../statics/images/icon.jpg" type="image/jpeg" size="32x32"/>
</head>
<body>
<div id="main">
    <div id="header">
        <div id="headerLeft">
            <div id="name"><a href="index.html">an9wer's blog</a></div>
            <div id="signature">just stick to it :)</div>
        </div>
        <div id="headerRight">
            <div id="avatar">
                <a href="https://github.com/an9wer" target="_blank"><img src="../statics/images/avatar.jpg"></a>
            </div>
        </div>
    </div>
    <div id="navbar">
        <a id="blog" href="../blog/index.html">Blog</a>
        <a id="notes" class="current" href="index.html">Notes</a>
        <a id="about" href="../about.html">About</a>
    </div>
    <div id="post">
        <div id="title">git</div>
        <div id="content">
<p>
There are three main components of a Git project:
</p>

<ol>
<li>
 <code>Working tree</code>: or working directory, consists of files that you are
    currently working on. The state of files in working tree is <code>modified</code>.

<li>
 <code>Index</code>: or staging area, is where commits are prepared. The state of files
    in index is <code>staged</code> or <code>tracked</code>.

<li>
 <code>Repository</code>: or repo, is the container that tracks the changes to your
    project files. It holds all the commits that have been made. The state of
    fils in repository is <code>committed</code>.

</ol>

<pre>
    working tree --(git add)-&gt; index --(git commit)-&gt; repository
</pre>
            

<div id="git status"><h1 id="git status">git status</h1></div>

<pre>
    git status [&lt;options&gt;...] [--] [&lt;pathspec&gt;...]
</pre>

<p>
Displays paths that have differences between the index file and the current
HEAD commit, paths that have differences between the working tree and the index
file, and paths in the working tree that are not tracked by Git.
</p>

<div id="git status-Options"><h2 id="Options">Options</h2></div>

<ul>
<li>
  <code>-s</code>: Give the output in the short-format.

<li>
  <code>-b</code>: Show the branch and tracking info even in short-format.

<li>
  <code>--porcelain[=version]</code>: Given the output in an easy-to-parse-format for
    scripts.The version parameter is used to specify the format version, which
    value is v1 (default) or v2.

<li>
  <code>--long</code>: Give the output in the long-format. This is the default.

<li>
  <code>-u[&lt;mode&gt;]</code>: Show untracked files. The mode parameter is used to
    specificed the handling of untracked files, if specified, it must be stuck
    to the option(e.g. <code>-uno</code>, but not <code>-u no</code>).

<ul>
<li>
  <code>no</code>: Show no untracked files.

<li>
  <code>normal</code>: Show untracked files and directories.

<li>
  <code>all</code>: Also show individual files in untracked directories. (default)

</ul>
<li>
  <code>--ignored</code>: Show ignored files as well.

</ul>


<div id="git symbolic-ref"><h1 id="git symbolic-ref">git symbolic-ref</h1></div>

<pre>
    git symbolic-ref [-q] [--short] &lt;name&gt;
    git symbolic-ref [-m &lt;reason&gt;] &lt;name&gt; &lt;ref&gt;
    git symbolic-ref --delete [-q] &lt;name&gt;
</pre>

<p>
When given on argument, reads which branch head the given symbolic refers to
and outputs its path, relative to the <code>.git</code> directory.
</p>

<p>
When given two arguments, creates or updates a symbolic ref <code>name</code> to point at
the given branch <code>ref</code>.
</p>

<p>
When given <code>--delete</code> and an additional argument, deletes the given symbolic
ref.
</p>

<p>
<span id="git symbolic-ref-Note"></span><strong id="Note">Note</strong>: The position of symbolic ref is located in <code>.git</code> directory (e.g.
<code>.git/HEAD</code>).
</p>

<div id="git symbolic-ref-Examples"><h2 id="Examples">Examples</h2></div>

<p>
Output the path refered by the symbolic ref <code>HEAD</code>.  
</p>
<pre>
    git symbolic-ref HEAD
</pre>

<p>
Create a symbolic ref named with <code>DEV</code>, then refers it to <code>refs/heads/dev</code>, if
the symbolic ref <code>DEV</code> doesn't exist.  Otherwise it will just update the
content of symbolic ref <code>DEV</code> to <code>refs/heads/dev</code>.
</p>
<pre>
    git symbolic-ref DEV refs/heads/dev
</pre>

<p>
Delete symbolic ref <code>DEV</code> created before.
</p>
<pre>
    git symbolic-ref --delete DEV
</pre>

<div id="git submodule"><h1 id="git submodule">git submodule</h1></div>

<div id="git submodule-Options"><h2 id="Options">Options</h2></div>

<p>
<code>--cached</code>: This option is only valid for status and summary commands. These
commands typically use the commit found in the submodule HEAD, but with this
option, the commit stored in the index is used instead.
</p>

<p>
<code>--files</code>: This option is only valid for the summary command. This command
compares the commit in the index with that in the submodule HEAD when this
option is used.
</p>

<div id="git submodule-git submodule add"><h2 id="git submodule add">git submodule add</h2></div>

<pre>
    git submodule add [-b &lt;branch&gt;] [-f|--force] [--name &lt;name&gt;]
        [--reference &lt;repository&gt;] [--depth &lt;depth&gt; [--] &lt;repository&gt; [&lt;path&gt;]
</pre>

<p>
Add the given repository as a submodule at the given path to the changeset to
be committed next to the current project: the current project is termed the
"superproject".
</p>

<p>
<code>&lt;repository&gt;</code> is the URL of the new submodule's orgin repository. This may be
either an absolute URL, or (if it begins with ./ or ../), the locaiton relative
to the superproject's default remote repository.
</p>

<p>
The optional argument <code>&lt;path&gt;</code> is the relative location for the cloned
submodule to exist in the superproject. If <code>&lt;path&gt;</code> is not given, the canonical
part of the source repository is used ("repo" for "/path/to/repo.git, "foo" for
"host.xz:foo/.git"). If <code>&lt;path&gt;</code> exists and is already a valid Git repository,
then it is staged for commit without cloning. The <code>&lt;path&gt;</code> is also used as the
submodule's logical name in its configuration entries unless <code>--name</code> is used
to specifiy a logical name.
</p>

<p>
The given URL is recorded into <code>.gitmodules</code> for use by subsequent users
cloning the superproject.
</p>

<div id="git submodule-git submodule add-Examples"><h3 id="Examples">Examples</h3></div>

<p>
Add a repository as a submodule at the given path, note that it can also be an
existed path.
</p>
<pre>
    git submodule add {repository url} /path/to/submodule
</pre>

<div id="git submodule-git submodule status"><h2 id="git submodule status">git submodule status</h2></div>

<pre>
    git submodule status [--cached] [--recursive] [--] [&lt;path&gt;...]
</pre>

<p>
Show the status of the submodules. This will print the SHA-1 of the currently
checked out commit for each submodule, along with the submodule path and the
output of <code>git describe</code> for the SHA-1.
</p>

<p>
Each SHA-1 will possibly be prefixed with '-' if the submodule is not
initialized, '+' if the currently checked out submodule commit does not match
the SHA-1 found in the index of the containing repository and 'U' if the
submoudle has merge conflicts.
</p>

<div id="git submodule-git submodule status-Examples"><h3 id="Examples">Examples</h3></div>

<p>
Show the status of the currently checked out commit for each submodule:
</p>
<pre>
    git submodule status
</pre>

<p>
Show the status of the indexed commit for each submodule:
</p>
<pre>
    git submodule status --cached
</pre>

<div id="git submodule-git submodule init"><h2 id="git submodule init">git submodule init</h2></div>

<pre>
    git submodule init [--] [&lt;path&gt;...]
</pre>

<p>
Initialize the submodules recorded in the index (which were added and committed
elsewhere) by setting <code>submodule.$name.url</code> in <code>.git/config</code>.
</p>

<p>
Optional &lt;path&gt; arguments limit which submodules will be initialized. If no
path is specified and submodule.active has been configured, submodules
configured to be active will be initialized, otherwise all submodules are
initialized.
</p>

<div id="git submodule-git submodule init-Examples"><h3 id="Examples">Examples</h3></div>

<p>
Add submodule configuration in <code>.git/config</code>:
</p>
<pre>
    git submodule init /path/to/submodule
</pre>

<div id="git submodule-git submodule deinit"><h2 id="git submodule deinit">git submodule deinit</h2></div>

<pre>
    git submodule deinit [-f|--force] (-all|[--] &lt;path&gt;...}
</pre>

<p>
Unregister the given submodules, i.e. remove the whole <code>submodule.$name</code>
section from <code>.git/config</code> together with ther work tree. Further calls to
<code>git submodule update</code>, <code>git submodule foreach</code> and <code>git submodule sync</code> will
skip any unregistered submodules until they are initialized again.o
</p>

<p>
<span id="git submodule-git submodule deinit-Note"></span><strong id="Note">Note</strong>: If you really want to remove a submodule from the repository and commit
that use <code>git rm</code> instead.
</p>

<div id="git submodule-git submodule deinit-Examples"><h3 id="Examples">Examples</h3></div>

<p>
Remove submodule configuration in <code>.git/config</code>:
</p>
<pre>
    git submodule deinit /path/to/submodule
</pre>

<p>
Remove submodule in superproject, this will also remove the configuration in
<code>.gitmodule</code> and <code>.git/config</code>:
</p>
<pre>
    git rm /path/to/submoudle
</pre>

<div id="git submodule-git submodule update"><h2 id="git submodule update">git submodule update</h2></div>

<pre>
    git submodule update [--init] [--remote] [-N|--no-fetch]
        [--[no-]recommend-shallow] [-f|--force] [--checkout|--rebase|--merge]
        [--reference &lt;repository] [--depth &lt;depth&gt;] [--recursive] [--jobs &lt;n&gt;]
        [--] [&lt;path&gt;...]
</pre>

<p>
Update the registered submodules to match what the superproject expects by
cloning missing submodules and updating the working tree of the submodules.
</p>

<ul>
<li>
  <code>--checkout</code>: The commit recorded in the superproject will be checked out
    in the submodule on a detached HEAD.

</ul>

<ul>
<li>
  <code>--rebase</code>: The current branch of the submodule will be rebased onto the
    commit recorded in the superproject.

</ul>

<ul>
<li>
  <code>--merge</code>: The commit recorded in the superproject will be merged into the
    current branch in the submodule.

</ul>

<p>
The following update procedures are only available via the
<code>submodule.&lt;name&gt;.update</code> configuration variable:
</p>

<ul>
<li>
  <code>custom command</code>: arbitrary shell command that takes a single argument (the
    sha1 of the commit recorded in the superproject) is executed. When
    <code>submodule.&lt;name&gt;.update</code> is set to <code>!command</code>, the remainder after the
    exclamation mark is the custom command.

</ul>

<ul>
<li>
  <code>none</code>: the submodule is not updated.

</ul>

<div id="git submodule-git submodule update-Examples"><h3 id="Examples">Examples</h3></div>

<p>
Update submodule to match what the superproject expects. By default, it will
create a detached branch for missing commits:
</p>
<pre>
    git submodule update /path/to/submodule
</pre>
<p>
or:
</p>
<pre>
    git submodule update --checkout /path/to/submodule
</pre>

<p>
Update submodule to match what the superproject expects. It will rebase missing
commits to current branch:
</p>
<pre>
    git submodule update --rebase /path/to/submodule
</pre>

<p>
Update submodule to match what the superproject expects. It will merge missing
commits to current branch:
</p>
<pre>
    git submodule update --merge /path/to/submodule
</pre>

<div id="git submodule-git submodule summary"><h2 id="git submodule summary">git submodule summary</h2></div>

<pre>
    git submodule summary [--cached|--files] [(-n|--summary-limit) &lt;n&gt;]
        [commit] [--] [&lt;path&gt;...]
</pre>

<p>
Show commit summary between the given commit (defaults to HEAD) and working
tree/index. For a submodule in question, a series of commits in the submodule
between the given super project commit and the index or working tree (switched
by <code>--cached</code>) are shown. If the option <code>--files</code> is given, show the series of
commits in the submodule between the index of the super project and the working
tree.
</p>

<div id="git submodule-git submodule summary-Examples"><h3 id="Examples">Examples</h3></div>

<p>
Show the summary of the currently checked out commit for each submodule:
</p>
<pre>
    git submodule summary
</pre>

<p>
Show the summary of the indexed commit for each submodule:
</p>
<pre>
    git submodule summary --cached
</pre>

<div id="git submodule-git submodule foreach"><h2 id="git submodule foreach">git submodule foreach</h2></div>

<pre>
    git submodule foreach [--recursive] &lt;command&gt;
</pre>

<p>
Evalutes an arbitrary shell command in each checked out submodule. The command
has access to the variables:
</p>

<ul>
<li>
  <code>$name</code>: The name of the relevant submodule section in <code>.gitmodules</code>.

<li>
  <code>$path</code>: The name of the submodule directory relative to the superproject.

<li>
  <code>$sha1</code>: The commit as recorded in the superproject.

<li>
  <code>$toplevel</code>: The absolute path ot the top-level of the superproject.

</ul>

<p>
Any submodules defined in the superproject but not checked out are ignored by
this command.
</p>

<p>
Unless given <code>--quiet</code>, foreach prints the name of each submodule before
evaluating the command.
</p>

<p>
A non-zero return from the command in any submodule causes the processing to
terminate. This can be overridden by adding <code>||</code> <code>:</code> to the end of the command.
</p>

<div id="git submodule-git submodule foreach-Examples"><h3 id="Examples">Examples</h3></div>

<p>
<span class="todo">TODO</span>
</p>

<div id="git submodule-git submodule sync"><h2 id="git submodule sync">git submodule sync</h2></div>

<pre>
    git submodule sync [--recursive] [--] [&lt;path&gt;...]
</pre>

<p>
Synchronizes submodules' remote URL configuration setting to the value
specified in <code>.gitmodules</code>. It will only affect those submodules which already
have a URL entry in <code>.git/config</code> (that is the case when they are initialized
or freshly added). This is useful when submodule URLs change upstream and you
need to update your local repositories accordingly.
</p>

<div id="git submodule-git submodule sync-Examples"><h3 id="Examples">Examples</h3></div>

<p>
Copy the URL entry in <code>.gitmodules</code> to <code>.git/config</code>:
</p>
<pre>
    git submodule sync /path/to/submodule
</pre>
</div>
    </div>
    <div id="footer">
        <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" target="_blank">CC BY-NC-SA</a> 2018 an9wer | powered by <a href="https://github.com/vimwiki/vimwiki" target="_blank">vimwiki</a>
    </div>
<div>
</body>
</html>
