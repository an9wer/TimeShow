= Bash Parameters

A variable may be assigned to by a statement of the form:

----
    name=[value]
----

If value is not given, the variable is assigned the null string. All values
undergo tilde expansion, parameter and variable expansion, command
substitution, arithmetic expansion, and quote removal.

In the context where an assignment statement is assigning a value to a shell
variable or array index, the += operator can be used to append to or add to the
variable's previous value. When += is applied to a variable for which the
integer attribute has been set, value is evaluated as an arithmetic expression
and added to the variable's current value, which is also evaluated. When += is
applied to an array variable using compound assignment, the variable's value is
not unset (as it is when using =), and new values are appended to the array
beginning at one greater then the array's maximum index (for indexed arrays) or
added as additional key-value pairs in an associative array. When applied to a
string-valued variable, value is expanded and appended to the variable's value.

----
    $ declare -i var=1+2
    $ var+=3
    $ declare -p var
    declare -i var="6"
----

----
    $ declare -a var=(1 2)
    $ var+=3
    $ declare -p var
    declare -a var=([0]="13" [1]="2")
----

----
    $ declare -a var=(1 2)
    $ var+=(3)
    $ declare -p var
    declare -a var=([0]="1" [1]="2" [2]="3")
----

----
    $ declare -- var="12"
    $ var+=3
    $ declare -p var
    declare -- var="123"
----

Assign multiple variables splitting by whitespace in one line:

----
    $ a=1 b=2 c=3
----

== Positional Parameters

TODO

== Special Parameters

=== parametedr *

`*`: Expands to the positional paramters, starting from one. When the expansion
is `not` within double quotes, each positional parameters expands to a separate
word. In contexts where it is performed, those words are subject to further
word splitting and pathname expansion. When the expansion occurs within double
quotes, it expands to a single word with the value of each parameter separated
by the first character of the `IFS` special variable. That is, ``$*'' is
equivalent to ``$1c$2c..'', where c is the first character of the value of the
IFS variable. If `IFS` is unset, the parameters are separated by spaces. If
`IFS` is null, the parameters are joined without intervening separators.

[TIP]
Let's see how `IFS` makes effect.

First create a function which displays `$*`:

----
    $ function func() { echo $*; }
----

Then:

----
    $ func 1 2 3
    1 2 3
----

Then set `IFS` to some value:

----
    $ IFS=a func 1 2 3
    1a2a3
----

Then unset IFS:

----
    $ unset IFS
    $ func 1 2 3
    1 2 3
----

Also, the length of `$*`:

----
    $ function func() { echo ${#*}; }
    $ func 1 2 3
    3
----

[TIP]
Let's take a look at the difference between `$*` and `"$*"`:

First create a function to display the elements in `$*` and `"$*"`:

----
    function func() { local a=($*) b=("$*"); declare -p a b; }
----

Then:

----
    $ func 1 2 3
    declare -a a=([0]="1" [1]="2" [2]="3")
    declare -a b=([0]="1 2 3")
----

We can find out that `$*` expands each parameter to a separate word, but `"$*"`
expands each parameter to one word.

=== Parameter @

`@`: Expands to the positional parameters, starting from one. When the
expansion occurs within double quotes, each parameter expands to a separate
word. That is, ``$@'' is equivalent to ``$1" "$2" ...''. If the double-quoted
expansion occurs within a word, the expansion of the first parameter is joined
with the beginning part of the original word, and the expansion of the last
parameter is joined with the last part of the original word. When there are no
posisional parameters, `"$@"` and `$@`  expand to nothing.

[TIP]
Let's take a look at the difference between `$@` and `"$@"`.

First create a function to display the elements in `$@` and `"$@"`:

----
    function func() { local a=($@) b=("$@"); declare -p a b; }
----

Then:

----
    $ func 1 2 3
    declare -a a=([0]="1" [1]="2" [2]="3")
    declare -a b=([0]="1" [1]="2" [2]="3")
----

We can find out that `$@` and `"$@"` are same.
