= git

There are three main components of a Git project:

1.  `Working tree`: or working directory, consists of files that you are
    currently working on. The state of files in working tree is `modified`.
2.  `Index`: or staging area, is where commits are prepared. The state of files
    in index is `staged` or `tracked`.
3.  `Repository`: or repo, is the container that tracks the changes to your
    project files. It holds all the commits that have been made. The state of
    fils in repository is `committed`.

----
    working tree --(git add)-> index --(git commit)-> repository
----
            

== git status

----
    git status [<options>...] [--] [<pathspec>...]
----

Displays paths that have differences between the index file and the current
HEAD commit, paths that have differences between the working tree and the index
file, and paths in the working tree that are not tracked by Git.

=== Options

-   `-s`: Give the output in the short-format.
-   `-b`: Show the branch and tracking info even in short-format.
-   `--porcelain[=version]`: Given the output in an easy-to-parse-format for
    scripts.The version parameter is used to specify the format version, which
    value is v1 (default) or v2.
-   `--long`: Give the output in the long-format. This is the default.
-   `-u[<mode>]`: Show untracked files. The mode parameter is used to
    specificed the handling of untracked files, if specified, it must be stuck
    to the option(e.g. `-uno`, but not `-u no`).
    **  `no`: Show no untracked files.
    **  `normal`: Show untracked files and directories.
    **  `all`: Also show individual files in untracked directories. (default)
-   `--ignored`: Show ignored files as well.


== git symbolic-ref

----
    git symbolic-ref [-q] [--short] <name>
    git symbolic-ref [-m <reason>] <name> <ref>
    git symbolic-ref --delete [-q] <name>
----

When given on argument, reads which branch head the given symbolic refers to
and outputs its path, relative to the `.git` directory.

When given two arguments, creates or updates a symbolic ref `name` to point at
the given branch `ref`.

When given `--delete` and an additional argument, deletes the given symbolic
ref.

*Note*: The position of symbolic ref is located in `.git` directory (e.g.
`.git/HEAD`).

=== Examples

Output the path refered by the symbolic ref `HEAD`.  

----
    git symbolic-ref HEAD
----

Create a symbolic ref named with `DEV`, then refers it to `refs/heads/dev`, if
the symbolic ref `DEV` doesn't exist.  Otherwise it will just update the
content of symbolic ref `DEV` to `refs/heads/dev`.

----
    git symbolic-ref DEV refs/heads/dev
----

Delete symbolic ref `DEV` created before.

----
    git symbolic-ref --delete DEV
----

== git submodule

=== Options

`--cached`: This option is only valid for status and summary commands. These
commands typically use the commit found in the submodule HEAD, but with this
option, the commit stored in the index is used instead.

`--files`: This option is only valid for the summary command. This command
compares the commit in the index with that in the submodule HEAD when this
option is used.

=== git submodule add

----
    git submodule add [-b <branch>] [-f|--force] [--name <name>]
        [--reference <repository>] [--depth <depth> [--] <repository> [<path>]
----

Add the given repository as a submodule at the given path to the changeset to
be committed next to the current project: the current project is termed the
"superproject".

`<repository>` is the URL of the new submodule's orgin repository. This may be
either an absolute URL, or (if it begins with ./ or ../), the locaiton relative
to the superproject's default remote repository.

The optional argument `<path>` is the relative location for the cloned
submodule to exist in the superproject. If `<path>` is not given, the canonical
part of the source repository is used ("repo" for "/path/to/repo.git, "foo" for
"host.xz:foo/.git"). If `<path>` exists and is already a valid Git repository,
then it is staged for commit without cloning. The `<path>` is also used as the
submodule's logical name in its configuration entries unless `--name` is used
to specifiy a logical name.

The given URL is recorded into `.gitmodules` for use by subsequent users
cloning the superproject.

==== Examples

Add a repository as a submodule at the given path, note that it can also be an
existed path.

----
    git submodule add {repository url} /path/to/submodule
----

=== git submodule status

----
    git submodule status [--cached] [--recursive] [--] [<path>...]
----

Show the status of the submodules. This will print the SHA-1 of the currently
checked out commit for each submodule, along with the submodule path and the
output of `git describe` for the SHA-1.

Each SHA-1 will possibly be prefixed with '-' if the submodule is not
initialized, '+' if the currently checked out submodule commit does not match
the SHA-1 found in the index of the containing repository and 'U' if the
submoudle has merge conflicts.

==== Examples

Show the status of the currently checked out commit for each submodule:

----
    git submodule status
----

Show the status of the indexed commit for each submodule:

----
    git submodule status --cached
----

=== git submodule init

----
    git submodule init [--] [<path>...]
----

Initialize the submodules recorded in the index (which were added and committed
elsewhere) by setting `submodule.$name.url` in `.git/config`.

Optional <path> arguments limit which submodules will be initialized. If no
path is specified and submodule.active has been configured, submodules
configured to be active will be initialized, otherwise all submodules are
initialized.

==== Examples

Add submodule configuration in `.git/config`:

----
    git submodule init /path/to/submodule
----

=== git submodule deinit

----
    git submodule deinit [-f|--force] (-all|[--] <path>...}
----

Unregister the given submodules, i.e. remove the whole `submodule.$name`
section from `.git/config` together with ther work tree. Further calls to
`git submodule update`, `git submodule foreach` and `git submodule sync` will
skip any unregistered submodules until they are initialized again.o

*Note*: If you really want to remove a submodule from the repository and commit
that use `git rm` instead.

==== Examples

Remove submodule configuration in `.git/config`:

----
    git submodule deinit /path/to/submodule
----

Remove submodule in superproject, this will also remove the configuration in
`.gitmodule` and `.git/config`:

----
    git rm /path/to/submoudle
----

=== git submodule update

----
    git submodule update [--init] [--remote] [-N|--no-fetch]
        [--[no-]recommend-shallow] [-f|--force] [--checkout|--rebase|--merge]
        [--reference <repository] [--depth <depth>] [--recursive] [--jobs <n>]
        [--] [<path>...]
----

Update the registered submodules to match what the superproject expects by
cloning missing submodules and updating the working tree of the submodules.

-   `--checkout`: The commit recorded in the superproject will be checked out
    in the submodule on a detached HEAD.

-   `--rebase`: The current branch of the submodule will be rebased onto the
    commit recorded in the superproject.

-   `--merge`: The commit recorded in the superproject will be merged into the
    current branch in the submodule.

The following update procedures are only available via the
`submodule.<name>.update` configuration variable:

-   `custom command`: arbitrary shell command that takes a single argument (the
    sha1 of the commit recorded in the superproject) is executed. When
    `submodule.<name>.update` is set to `!command`, the remainder after the
    exclamation mark is the custom command.

-   `none`: the submodule is not updated.

==== Examples

Update submodule to match what the superproject expects. By default, it will
create a detached branch for missing commits:

----
    git submodule update /path/to/submodule
----

or:

----
    git submodule update --checkout /path/to/submodule
----

Update submodule to match what the superproject expects. It will rebase missing
commits to current branch:

----
    git submodule update --rebase /path/to/submodule
----

Update submodule to match what the superproject expects. It will merge missing
commits to current branch:

----
    git submodule update --merge /path/to/submodule
----

Update submodule which hasn't been initialized:

----
    git submodule update --init /path/to/submodule
----

=== git submodule summary

----
    git submodule summary [--cached|--files] [(-n|--summary-limit) <n>]
        [commit] [--] [<path>...]
----

Show commit summary between the given commit (defaults to HEAD) and working
tree/index. For a submodule in question, a series of commits in the submodule
between the given super project commit and the index or working tree (switched
by `--cached`) are shown. If the option `--files` is given, show the series of
commits in the submodule between the index of the super project and the working
tree.

==== Examples

Show the summary of the currently checked out commit for each submodule:

----
    git submodule summary
----

Show the summary of the indexed commit for each submodule:

----
    git submodule summary --cached
----

=== git submodule foreach

----
    git submodule foreach [--recursive] <command>
----

Evalutes an arbitrary shell command in each checked out submodule. The command
has access to the variables:

-   `$name`: The name of the relevant submodule section in `.gitmodules`.

-   `$path`: The name of the submodule directory relative to the superproject.

-   `$sha1`: The commit as recorded in the superproject.

-   `$toplevel`: The absolute path ot the top-level of the superproject.

Any submodules defined in the superproject but not checked out are ignored by
this command.

Unless given `--quiet`, foreach prints the name of each submodule before
evaluating the command.

A non-zero return from the command in any submodule causes the processing to
terminate. This can be overridden by adding `||` `:` to the end of the command.

==== Examples

TODO

=== git submodule sync

----
    git submodule sync [--recursive] [--] [<path>...]
----

Synchronizes submodules' remote URL configuration setting to the value
specified in `.gitmodules`. It will only affect those submodules which already
have a URL entry in `.git/config` (that is the case when they are initialized
or freshly added). This is useful when submodule URLs change upstream and you
need to update your local repositories accordingly.

==== Examples

Copy the URL entry in `.gitmodules` to `.git/config`:

----
    git submodule sync /path/to/submodule
----

