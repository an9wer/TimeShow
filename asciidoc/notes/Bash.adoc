== Options

=== -c option

`-c`: If the `-c` option is present, then command are read from the *first*
non-option argument command string. If there are arguments after the command
string, the first argument is assigned to $0 and any remaining arguments are
assigned to the positional parameters. The assignment to $0 sets the name of
the shell, which is used in warning and error messages. 

-   The command below will display 123:
----
    $ bash -c "echo 123"
    123
----

-   *Note*: It only treat the first non-option argument as command string, so
    the following command won't display 123:
----
    $ bash -c echo 123

----

*Note*: By default, bash will read commands from some file. Use `-c` option
can make bash to execute command from string.


== Variables

`PROMPT_COMMAND`: If set, the value is executed as a command prior to issuing
each primary prompt.

== Quoting

=== $'string'

Words of the form $'string' are treated specially. The word expands to string,
with backslash-escaped characters replaced as specified  by the ANSI C
standard. Backslash escape sequences, if present, are decoded as follows:

|===
| \a         |   alert (bell)
| \b         |   backspace
| \e \E      |   an escape character
| \f         |   form feed
| \n         |   new line
| \r         |   carriage return
| \t         |   horizontal tab
| \v         |   vertical tab
| \\         |   backslash
| \'         |   single quote
| \"         |   double quote
| \?         |   question mark
| \nnn       |   the eight-bit character whose value is the octal value nnn (one to three digits)
| \xHH       |   the eight-bit character whose value is the hexadecimal value HH (one or two hex digits)
| \uHHHH     |   the Unicode (ISO/IEC 10646) character whose value is the hexadecimal value HHHH (one to four hex digits)
| \UHHHHHHHH |   the Unicode (ISO/IEC 10646) character whose value is the hexadecimal value HHHHHHHH (one to eight hex digits)
| \cx        |   a control-x character
|===

The expanded result is single-quoted, as if the dollar sign had not been
present. For example:

----
    $ echo abc$'\b'd
    abd
----

----
    $ echo 123$'\n'321
    123
    321
----

(Find example code in https://github.com/an9wer/ltips/blob/master/Bash/quoting.sh[here])

=== $"string"

A double-quoted string preceded by a dollar sign $"string" will cause the
string to be translated according to the current locale.  If the current locale
is C or POSIX, the dollar sign is ignored.  If the string is translated and
replaced, the replacement is double-quoted. For example:

----
    $ echo abc$"\b"d
    abc\bd
----

----
    $ echo 123$"\n"321
    123\n321
----

(Find example in https://github.com/an9wer/ltips/blob/master/Bash/quoting.sh[here])

== Array

Any element of an array may be referenced using `${name[subscript]}`. The
braces are required to avoid conflicts with pathname expansion. If subscript is
@ or *, the word expansion to all members of name. These subscripts differ only
when the word appears whin double quotes. If the word is double-quoted,
`${name[*]}` expands to a single word with the value of each array member
separated by the first character of the `IFS` special variable, and
`${name[@]}` expands each element of name to a separate word.

{{{
    $ var=(1 2 3)
    $ a=(${var[@]})
    $ b=("${var[@]}")
    $ declare -p a b
    declare -a a=([0]="1" [1]="2" [2]="3")
    declare -a b=([0]="1" [1]="2" [2]="3")
    declare -- a="1 2 3"
    declare -- b="1 2 3"
}}}

{{{
    $ var=(1 2 3)
    $ a=(${var[*]})
    $ b=("${var[*]}")
    $ declare -p a b
    declare -a a=([0]="1" [1]="2" [2]="3")
    declare -a b=([0]="1 2 3")
}}}

{{{
    $ IFS=- var=(1 2 3)
    $ a=(${var[*]})
    $ b=("${var[*]}")
    $ declare -p a b
    declare -a a=([0]="1" [1]="2" [2]="3")
    declare -a b=([0]="1-2-3")
}}}

== Conditional expressions

Conditional expressions are used by the `[[` compound command and the `test`
and `[` builtin commands to test file attributes and perform string and
arithmetic comparisons.

{{{
    string1 == string2
    string1 = string2
}}}
True if the strings are equal. `=` should be used with the `test` command for
POSIX conformance.

{{{
    string1 != string2
}}}
True if strings are not equal.

{{{
    arg1 OP arg2
}}}
`OP` is one of `-eq, -ne, -lt, -le, -gt or -ge`. These arithmetic binary
operators return true if arg1 is euqal to, not equal to, less than, less than
or equal to, greater than, or greater than or equal to arg2, respectively. Arg1
and arg2 may be positive or negative integers.

== References ==

-   [[https://www.gnu.org/software/bash/manual/bash.html|GNU bash manual]]

-   `man bash`
