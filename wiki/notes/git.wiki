There are three main components of a Git project:

1.  `Working tree`: or working directory, consists of files that you are
    currently working on. The state of files in working tree is `modified`.
2.  `Index`: or staging area, is where commits are prepared. The state of files
    in index is `staged` or `tracked`.
3.  `Repository`: or repo, is the container that tracks the changes to your
    project files. It holds all the commits that have been made. The state of
    fils in repository is `committed`.

{{{
    working tree --(git add)-> index --(git commit)-> repository
}}}
            

= git status =

{{{
    git status [<options>...] [--] [<pathspec>...]
}}}

== Options ==

-   `-s`: Give the output in the short-format.
-   `-b`: Show the branch and tracking info even in short-format.
-   `--porcelain[=version]`: Given the output in an easy-to-parse-format for
    scripts.The version parameter is used to specify the format version, which
    value is v1 (default) or v2.
-   `--long`: Give the output in the long-format. This is the default.
-   `-u[<mode>]`: Show untracked files. The mode parameter is used to
    specificed the handling of untracked files, if specified, it must be stuck
    to the option(e.g. `-uno`, but not `-u no`).
    -   `no`: Show no untracked files.
    -   `normal`: Show untracked files and directories.
    -   `all`: Also show individual files in untracked directories. (default)
-   `--ignored`: Show ignored files as well.


= git symbolic-ref =

{{{
    git symbolic-ref [-q] [--short] <name>
    git symbolic-ref [-m <reason>] <name> <ref>
    git symbolic-ref --delete [-q] <name>
}}}

When given on argument, reads which branch head the given symbolic refers to
and outputs its path, relative to the `.git` directory.

When given two arguments, creates or updates a symbolic ref `name` to point at
the given branch `ref`.

When given `--delete` and an additional argument, deletes the given symbolic
ref.

*Note*: The position of symbolic ref is located in `.git` directory (e.g.
`.git/HEAD`).

== Examples ==

Output the path refered by the symbolic ref `HEAD`.  
{{{
    git symbolic-ref HEAD
}}}

Create a symbolic ref named with `DEV`, then refers it to `refs/heads/dev`, if
the symbolic ref `DEV` doesn't exist.  Otherwise it will just update the
content of symbolic ref `DEV` to `refs/heads/dev`.
{{{
    git symbolic-ref DEV refs/heads/dev
}}}

Delete symbolic ref `DEV` created before.
{{{
    git symbolic-ref --delete DEV
}}}

= git submodule =

== git submodule add ==

{{{
    git submodule add [-b <branch>] [-f|--force] [--name <name>]
        [--reference <repository>] [--depth <depth> [--] <repository> [<path>]
}}}

Add the given repository as a submodule at the given path to the changeset to
be committed next to the current project: the current project is termed the
"superproject".

`<repository>` is the URL of the new submodule's orgin repository. This may be
either an absolute URL, or (if it begins with ./ or ../), the locaiton relative
to the superproject's default remote repository.

The optional argument `<path>` is the relative location for the cloned
submodule to exist in the superproject. If `<path>` is not given, the canonical
part of the source repository is used ("repo" for "/path/to/repo.git, "foo" for
"host.xz:foo/.git"). If `<path>` exists and is already a valid Git repository,
then it is staged for commit without cloning. The `<path>` is also used as the
submodule's logical name in its configuration entries unless `--name` is used
to specifiy a logical name.

The given URL is recorded into `.gitmodules` for use by subsequent users
cloning the superproject.

== git submodule status ==

{{{
    git submodule status [--cached] [--recursive] [--] [<path>...]
}}}

Show the status of the submodules. This will print the SHA-1 of the currently
checked out commit for each submodule, along with the submodule path and the
output of `git describe` for the SHA-1.

Each SHA-1 will possibly be prefixed with '-' if the submodule is not
initialized, '+' if the currently checked out submodule commit does not match
the SHA-1 found in the index of the containing repository and 'U' if the
submoudle has merge conflicts.

== git submodule init ==

{{{
    git submodule init [--] [<path>...]
}}}

Initialize the submodules recorded in the index (which were added and committed
elsewhere) by setting `submodule.$name.url` in `.git/config`.

Optional <path> arguments limit which submodules will be initialized. If no
path is specified and submodule.active has been configured, submodules
configured to be active will be initialized, otherwise all submodules are
initialized.

== git submodule deinit ==

{{{
    git submodule deinit [-f|--force] (-all|[--] <path>...}
}}}

Unregister the given submodules, i.e. remove the whole `submodule.$name`
section from `.git/config` together with ther work tree. Further calls to
`git submodule update`, `git submodule foreach` and `git submodule sync` will
skip any unregistered submodules until they are initialized again.o

*Note*: If you really want to remove a submodule from the repository and commit
that use `git rm` instead.

== git submodule update ==

{{{
    git submodule update [--init] [--remote] [-N|--no-fetch]
        [--[no-]recommend-shallow] [-f|--force] [--checkout|--rebase|--merge]
        [--reference <repository] [--depth <depth>] [--recursive] [--jobs <n>]
        [--] [<path>...]
}}}

Update the registered submodules to match what the superproject expects by
cloning missing submodules and updating the working tree of the submodules.

-   `--checkout`: The commit recorded in the superproject will be checked out
    in the submodule on a detached HEAD.

-   `--rebase`: The current branch of the submodule will be rebased onto the
    commit recorded in the superproject.

-   `--merge`: The commit recorded in the superproject will be merged into the
    current branch in the submodule.

The following update procedures are only available via the
`submodule.<name>.update` configuration variable:

-   `custom command`: arbitrary shell command that takes a single argument (the
    sha1 of the commit recorded in the superproject) is executed. When
    `submodule.<name>.update` is set to `!command`, the remainder after the
    exclamation mark is the custom command.

-   `none`: the submodule is not updated.

== git submodule summary ==

TODO

== git submodule foreach ==

TODO

== git submodule sync ==

{{{
    git submodule sync [--recursive] [--] [<path>...]
}}}

Synchronizes submodules' remote URL configuration setting to the value
specified in `.gitmodules`. It will only affect those submodules which already
have a URL entry in `.git/config` (that is the case when they are initialized
or freshly added). This is useful when submodule URLs change upstream and you
need to update your local repositories accordingly.


