= Options =

== -c option ==

`-c`: If the `-c` option is present, then command are read from the *first*
non-option argument command string. If there are arguments after the command
string, the first argument is assigned to $0 and any remaining arguments are
assigned to the positional parameters. The assignment to $0 sets the name of
the shell, which is used in warning and error messages. 

-   The command below will display 123:
    {{{
        $ bash -c "echo 123"
        123
    }}}

-   *Note*: It only treat the first non-option argument as command string, so
    the following command won't display 123:
    {{{
        $ bash -c echo 123

    }}}

*Note*: By default, bash will read commands from some file. Use `-c` option
can make bash to execute command from string.


= Variables =

`PROMPT_COMMAND`: If set, the value is executed as a command prior to issuing
each primary prompt.

= Quoting =

== $'string' ==

Words of the form $'string' are treated specially. The word expands to string,
with backslash-escaped characters replaced as specified  by the ANSI C
standard. Backslash escape sequences, if present, are decoded as follows:

{{{
    \a             alert (bell)
    \b             backspace
    \e
    \E             an escape character
    \f             form feed
    \n             new line
    \r             carriage return
    \t             horizontal tab
    \v             vertical tab
    \\             backslash
    \'             single quote
    \"             double quote
    \?             question mark
    \nnn           the eight-bit character whose value is the octal value nnn (one to three digits)
    \xHH           the eight-bit character whose value is the hexadecimal value HH (one or two hex digits)
    \uHHHH         the Unicode (ISO/IEC 10646) character whose value is the hexadecimal value HHHH (one to four hex digits)
    \UHHHHHHHH     the Unicode (ISO/IEC 10646) character whose value is the hexadecimal value HHHHHHHH (one to eight hex digits)
    \cx            a control-x character
}}}

The expanded result is single-quoted, as if the dollar sign had not been
present. For example:

{{{
    $ echo abc$'\b'd
    abd
}}}
{{{
    $ echo 123$'\n'321
    123
    321
}}}

(Find example code in [[https://github.com/an9wer/ltips/blob/master/Bash/quoting.sh|here]])

== $"string" ==

A double-quoted string preceded by a dollar sign `$"string"` will cause the
string to be translated according to the current locale.  If the current locale
is C or POSIX, the dollar sign is ignored.  If the string is translated and
replaced, the replacement is double-quoted. For example:

{{{
    $ echo abc$"\b"d
    abc\bd
}}}
{{{
    $ echo 123$"\n"321
    123\n321
}}}

(Find example code in [[https://github.com/an9wer/ltips/blob/master/Bash/quoting.sh|here]])

= Parameters =

== Special parameters ==


=== parametedr * ===

`*`: Expands to the positional paramters, starting from one. When the expansion
is `not` within double quotes, each positional parameters expands to a separate
word. In contexts where it is performed, those words are subject to further
word splitting and pathname expansion. When the expansion occurs within double
quotes, it expands to a single word with the value of each parameter separated
by the first character of the `IFS` special variable. That is, `"$*"` is
equivalent to `"$1c$2c.."`, where c is the first character of the value of the
IFS variable. If `IFS` is unset, the parameters are separated by spaces. If
`IFS` is null, the parameters are joined without intervening separators.

Let's see how `IFS` makes effect.

First create a function which displays `$*`:
{{{
    $ function func() { echo $*; }
}}}

Then:
{{{
    $ func 1 2 3
    1 2 3
}}}

Then set IFS to other value:
{{{
    $ IFS=a func 1 2 3
    1a2a3
}}}

Then unset IFS:
{{{
    $ unset IFS; func 1 2 3
    1 2 3
}}}

Also, let's check the length of `$*`:
{{{
    $ function func() { echo ${#*}; }
    $ func 1 2 3
}}}

Let's see the difference between `$*` and `"$*"`.

First create a function to display the elements in `$*` and `"$*"`:
{{{
    function func() { local a=($*) b=("$*"); declare -p a b; }
}}}

Then:
{{{
    $ func 1 2 3
    declare -a a=([0]="1" [1]="2" [2]="3")
    declare -a b=([0]="1 2 3")
}}}

We can find out that `$*` expands each parameter to a separate word, but `"$*"`
expands each parameter to one word.

=== Parameter @ ===

`@`: Expands to the positional parameters, starting from one. When the
expansion occurs within double quotes, each parameter expands to a separate
word. That is, `"$@"` is equivalent to `"$1" "$2" ...`. If the double-quoted
expansion occurs within a word, the expansion of the first parameter is joined
with the beginning part of the original word, and the expansion of the last
parameter is joined with the last part of the original word. When there are no
posisional parameters, `"$@"` and `$@`  expand to nothing.

Let's see the difference between `$@` and `"$@"`.

First create a function to display the elements in `$@` and `"$@"`:
{{{
    function func() { local a=($@) b=("$@"); declare -p a b; }
}}}

Then:
{{{
    $ func 1 2 3
    declare -a a=([0]="1" [1]="2" [2]="3")
    declare -a b=([0]="1" [1]="2" [2]="3")
}}}

We can find out that `$@` and `"$@"` are same.

= Parameter Expansion =

== Use default values ==

{{{
    ${parameter:-word}
}}}

If parameter is unset or null, the expansion of word is substituted. Otherwise,
the value of parameter is substituted.

{{{
    $ unset a
    $ echo ${a:-123}
    123
    $ echo ${a}

}}}


== Assign default values ==

{{{
    ${parameters:=word}
}}}

If parameter is unset or null, the expansion of word is assigned to parameter.
The value of parameter is then substituted. 

*Note*: Positional parameters and special parameters may not be assigned to in
this way.

{{{
    $ unset a
    $ echo ${a:=123}
    123
    $ echo ${a}
    123
}}}


== Substring expansion ==

{{{
    ${parameter:offset}
    ${parameter:offset:length}
}}}

It expands to the substring of the value of `parameter` starting at the
character specified by `offset` and expanding to up to `length` characters.

`offset` and `length` are arithmetic expressions. If `offset` or `length`
evaluates to a number less than zero, the value is used as an offset in
characters from the end of value of `parameter`.

*Note* that a negative `offset` must be separated from the colon by at least
one space to avoid being confused with the `:-` expansion. 

When `parameter` is a variable whose value is string:

{{{
    $ string=0123456789
    $ echo ${string:2}
    23456789
    $ echo ${string:2:4}
    2345
    $ echo ${string:2:-2}
    234567
    $ echo ${string: -4}
    6789
    $ echo ${string: -4:-2}
    67
}}}

{{{
    $ array[0]=0123456789
    $ echo ${array[0]:2}
    23456789
    $ echo ${array[0]:2:4}
    2345
    $ echo ${array[0]:2:-2}
    234567
    $ echo ${array[0]: -4}
    6789
    $ echo ${array[0]: -4:-2}
    67
}}}

When `parameter` is '@' (*Note*: it's an expansion error if `length` evaluates
to number less than zero):

{{{
    $ set -- 0 1 2 3 4 5 6 7 8 9
    $ echo ${@:2}
    23456789
    $ echo ${@:2:4}
    2345
    $ echo ${@:2:-2}
    bash: -2: substring expression < 0
    $ echo ${@: -4}
    6789
    $ echo ${@: -4:-2}
    bash: -2: substring expression < 0
}}}

When `parameter` is an indexed array name subscripted by '@' or '*' (*Note*:
it's an expansion error if `length` evaluates to number less than zero):

{{{
    $ array=(0 1 2 3 4 5 6 7 8 9)
    $ echo ${array[@]:2}
    23456789
    $ echo ${array[@]:2:4}
    2345
    $ echo ${array[@]:2:-2}
    bash: -2: substring expression < 0
    $ echo ${array[@]: -4}
    6789
    $ echo ${array[@]: -4:-2}
    bash: -2: substring expression < 0
}}}

(Find example code in [[https://github.com/an9wer/ltips/blob/master/Bash/parameter_expansion.sh|here]])


= Built-in =

== : ==

{{{
    : [arguments]
}}}

Do noting beyond expanding arguments and performing redirections. The return
status is zero.

-   Do expand arguments:
    {{{
        $ : ${a:=123}
        $ echo $a
        123
    }}}

-   Do flush file content:
    {{{
        $ :>/path/to/file
        $ cat /path/to/file

    }}}

== References ==

-   [[https://www.gnu.org/software/bash/manual/bash.html|GNU bash manual]]

-   `man bash`
